# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `connection_pool` gem.
# Please instead update this file by running `bin/tapioca gem connection_pool`.


# source://connection_pool//lib/connection_pool/version.rb#1
class ConnectionPool
  # source://connection_pool//lib/connection_pool.rb#90
  def initialize(options = T.unsafe(nil), &block); end

  # source://connection_pool//lib/connection_pool.rb#172
  def auto_reload_after_fork; end

  # source://connection_pool//lib/connection_pool.rb#175
  def available; end

  # source://connection_pool//lib/connection_pool.rb#129
  def checkin(force: T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool.rb#119
  def checkout(options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool.rb#180
  def idle; end

  # source://connection_pool//lib/connection_pool.rb#165
  def reap(idle_seconds = T.unsafe(nil), &block); end

  # source://connection_pool//lib/connection_pool.rb#159
  def reload(&block); end

  # source://connection_pool//lib/connection_pool.rb#150
  def shutdown(&block); end

  # source://connection_pool//lib/connection_pool.rb#170
  def size; end

  # source://connection_pool//lib/connection_pool.rb#105
  def then(options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool.rb#105
  def with(options = T.unsafe(nil)); end

  class << self
    # source://connection_pool//lib/connection_pool.rb#52
    def after_fork; end

    # source://connection_pool//lib/connection_pool.rb#44
    def wrap(options, &block); end
  end
end

# source://connection_pool//lib/connection_pool.rb#42
ConnectionPool::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://connection_pool//lib/connection_pool.rb#5
class ConnectionPool::Error < ::RuntimeError; end

# source://connection_pool//lib/connection_pool.rb#70
module ConnectionPool::ForkTracker
  # source://connection_pool//lib/connection_pool.rb#71
  def _fork; end
end

# source://connection_pool//lib/connection_pool.rb#49
ConnectionPool::INSTANCES = T.let(T.unsafe(nil), ObjectSpace::WeakMap)

# source://connection_pool//lib/connection_pool.rb#7
class ConnectionPool::PoolShuttingDownError < ::ConnectionPool::Error; end

# source://connection_pool//lib/connection_pool/timed_stack.rb#20
class ConnectionPool::TimedStack
  # source://connection_pool//lib/connection_pool/timed_stack.rb#27
  def initialize(size = T.unsafe(nil), &block); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#41
  def <<(obj, options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#125
  def empty?; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#138
  def idle; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#132
  def length; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#21
  def max; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#64
  def pop(timeout = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#41
  def push(obj, options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#104
  def reap(idle_seconds, &block); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#90
  def shutdown(reload: T.unsafe(nil), &block); end

  private

  # source://connection_pool//lib/connection_pool/timed_stack.rb#153
  def connection_stored?(options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#144
  def current_time; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#162
  def fetch_connection(options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#198
  def idle_connections?(idle_seconds); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#185
  def reserve_idle_connection(idle_seconds); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#171
  def shutdown_connections(options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#207
  def store_connection(obj, options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#217
  def try_create(options = T.unsafe(nil)); end
end

# source://connection_pool//lib/connection_pool.rb#9
class ConnectionPool::TimeoutError < ::Timeout::Error; end

# source://connection_pool//lib/connection_pool/version.rb#2
ConnectionPool::VERSION = T.let(T.unsafe(nil), String)

# source://connection_pool//lib/connection_pool/wrapper.rb#2
class ConnectionPool::Wrapper < ::BasicObject
  # source://connection_pool//lib/connection_pool/wrapper.rb#5
  def initialize(options = T.unsafe(nil), &block); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#35
  def method_missing(name, *args, **kwargs, &block); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#25
  def pool_available; end

  # source://connection_pool//lib/connection_pool/wrapper.rb#17
  def pool_shutdown(&block); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#21
  def pool_size; end

  # source://connection_pool//lib/connection_pool/wrapper.rb#29
  def respond_to?(id, *args); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#13
  def with(&block); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#9
  def wrapped_pool; end
end

# source://connection_pool//lib/connection_pool/wrapper.rb#3
ConnectionPool::Wrapper::METHODS = T.let(T.unsafe(nil), Array)

module Process
  extend ::ConnectionPool::ForkTracker
  extend ::RedisClient::PIDCache::CoreExt
  extend ::ActiveSupport::ForkTracker::CoreExt
end
