# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `connection_pool` gem.
# Please instead update this file by running `bin/tapioca gem connection_pool`.


# source://connection_pool//lib/connection_pool/version.rb#1
class ConnectionPool
  # source://connection_pool//lib/connection_pool.rb#48
  def initialize(timeout: T.unsafe(nil), size: T.unsafe(nil), auto_reload_after_fork: T.unsafe(nil), name: T.unsafe(nil), &_arg4); end

  # source://connection_pool//lib/connection_pool.rb#173
  def available; end

  # source://connection_pool//lib/connection_pool.rb#123
  def checkin(force: T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool.rb#111
  def checkout(timeout: T.unsafe(nil), **_arg1); end

  # source://connection_pool//lib/connection_pool.rb#107
  def discard_current_connection(&block); end

  # source://connection_pool//lib/connection_pool.rb#178
  def idle; end

  # source://connection_pool//lib/connection_pool.rb#168
  def reap(idle_seconds: T.unsafe(nil), &_arg1); end

  # source://connection_pool//lib/connection_pool.rb#162
  def reload(&_arg0); end

  # source://connection_pool//lib/connection_pool.rb#154
  def shutdown(&_arg0); end

  # source://connection_pool//lib/connection_pool.rb#46
  def size; end

  # source://connection_pool//lib/connection_pool.rb#75
  def then(**_arg0); end

  # source://connection_pool//lib/connection_pool.rb#60
  def with(**_arg0); end

  class << self
    # source://connection_pool//lib/connection_pool/fork.rb#6
    def after_fork; end

    # source://connection_pool//lib/connection_pool.rb#42
    def wrap(**_arg0, &_arg1); end
  end
end

# source://connection_pool//lib/connection_pool.rb#5
class ConnectionPool::Error < ::RuntimeError; end

# source://connection_pool//lib/connection_pool/fork.rb#21
module ConnectionPool::ForkTracker
  # source://connection_pool//lib/connection_pool/fork.rb#22
  def _fork; end
end

# source://connection_pool//lib/connection_pool/fork.rb#3
ConnectionPool::INSTANCES = T.let(T.unsafe(nil), ObjectSpace::WeakMap)

# source://connection_pool//lib/connection_pool.rb#7
class ConnectionPool::PoolShuttingDownError < ::ConnectionPool::Error; end

# source://connection_pool//lib/connection_pool/timed_stack.rb#19
class ConnectionPool::TimedStack
  # source://connection_pool//lib/connection_pool/timed_stack.rb#25
  def initialize(size: T.unsafe(nil), &block); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#50
  def <<(obj, **_arg1); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#143
  def decrement_created; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#125
  def empty?; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#137
  def idle; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#131
  def length; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#20
  def max; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#62
  def pop(timeout: T.unsafe(nil), exception: T.unsafe(nil), **_arg2); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#38
  def push(obj, **_arg1); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#106
  def reap(idle_seconds:); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#92
  def shutdown(reload: T.unsafe(nil), &block); end

  private

  # source://connection_pool//lib/connection_pool/timed_stack.rb#167
  def connection_stored?(**_arg0); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#149
  def current_time; end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#175
  def fetch_connection(**_arg0); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#209
  def idle_connections?(idle_seconds); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#195
  def reserve_idle_connection(idle_seconds); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#183
  def shutdown_connections(**_arg0); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#220
  def store_connection(obj, **_arg1); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#229
  def try_create(**_arg0); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#159
  def try_fetch_connection(**_arg0); end
end

# source://connection_pool//lib/connection_pool.rb#9
class ConnectionPool::TimeoutError < ::Timeout::Error; end

# source://connection_pool//lib/connection_pool/version.rb#2
ConnectionPool::VERSION = T.let(T.unsafe(nil), String)

# source://connection_pool//lib/connection_pool/wrapper.rb#2
class ConnectionPool::Wrapper < ::BasicObject
  # source://connection_pool//lib/connection_pool/wrapper.rb#5
  def initialize(**options, &_arg1); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#37
  def method_missing(name, *_arg1, **_arg2, &_arg3); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#25
  def pool_available; end

  # source://connection_pool//lib/connection_pool/wrapper.rb#17
  def pool_shutdown(&_arg0); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#21
  def pool_size; end

  # source://connection_pool//lib/connection_pool/wrapper.rb#29
  def respond_to?(id, *_arg1, **_arg2); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#13
  def with(**_arg0, &_arg1); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#9
  def wrapped_pool; end

  private

  # source://connection_pool//lib/connection_pool/wrapper.rb#33
  def respond_to_missing?(id, *_arg1, **_arg2); end
end

# source://connection_pool//lib/connection_pool/wrapper.rb#3
ConnectionPool::Wrapper::METHODS = T.let(T.unsafe(nil), Array)

module Process
  extend ::ConnectionPool::ForkTracker
  extend ::RedisClient::PIDCache::CoreExt
  extend ::ActiveSupport::ForkTracker::CoreExt
end
